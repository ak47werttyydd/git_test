import networkx as nx
import torch
import torch.nn as nn
import random
from collections import OrderedDict
from abc import ABCMeta, abstractmethod
import os

import op_projection as opp
import op_constraint as opc

class RandomGraph():
    def __init__(self, node_num, graph_mode, **graph_param):
        self.node_num = node_num
        self.graph = None # After calling generete_graph, this should be a networkx class.
        self.graph_mode = graph_mode
        self.graph_param = graph_param
    
    def set_params(self, graph_mode, **graph_param):
        self.graph_mode = graph_mode  
        self.graph_param = graph_param
    
    def _random_graph_generator(self):
        if self.graph_mode == "WS":  #need args:  node: n, k neighbors:k, prob: p
            graph = nx.random_graphs.connected_watts_strogatz_graph(self.node_num, **self.graph_param)
        elif self.graph_mode == "ER":
            graph = nx.random_graphs.erdos_renyi_graph(self.node_num, **self.graph_param)
        elif self.graph_mode == "BA":
            graph = nx.random_graphs.barabasi_albert_graph(self.node_num, **self.graph_param)
        elif self.graph_mode == "None":
            raise Exception("Please set random graph generation parameters")
        else:
            raise Exception("Random graph generator not implemented")
        self.graph = graph       

    @staticmethod
    def parse_graph(graph):
        ''' parse the networkx graph to list of node and 
        list of edge(node index -> [node index])'''
        # Turning networkx graph into list of edges.
        # edges: vertex index --> list(vertex index)
        # index < vertex index so that later we can
        # run the computation graph more smoothly 

        '''
        adding two nodes to the original graph
        nodes[0] is the input node, 
        the last node is the output node

        if the random graph consists of components
        the smallest nodes of every component connect to the input node
        In any components nodes just with inputs connect to the output node
        '''

        node_num = graph.number_of_nodes()
        edges = OrderedDict() 
        edges[0] = []   #0 is key, the empty list is the value. i.e. the input node has no input
        nodes = [0] #add the input node
        out_edge = list()
        for node in graph.nodes(): #node is in int
            # Node in networkx graph is int
            neighbors = list(graph.neighbors(node))
            neighbors.sort() #neighbors are sorted
            #print(f"node {node}'s neighbor is",neighbors)
            edge = list() #edge is the set of input of a node
            for neighbor in neighbors:   #neighbor is in int
                # we assign indices to all nodes in a graph, 
                # and set the direction of every edge as pointing 
                # from the smaller-index node to the larger-index one.
                # ---- Appendix of the paper.
                if node > neighbor: #set the direction of edge from low index to high index, rule out the duplicate edge
                    edge.append(neighbor + 1) #+1 means the new index of nodes plus 1
            in_edge_num = len(edge) #edge are the set of input edges of a node
            if len(neighbors) == in_edge_num:  
                # Node has only input edge, so it is the last node of a component
                # connect it to the common output node
                out_edge.append(node + 1)
            if in_edge_num == 0:
                #Node has no input edge, so it is the first node of a component
                #connect it to the input node
                edge.append(0)
            nodes.append(node + 1)  # add nodes generated by networkx
            edges[node + 1] = edge
        nodes.append(node_num + 1) #add the output node
        edges[node_num + 1] = out_edge
        return nodes, edges

    def generate_graph(self):  
        ''' Generate graph based on random graph generator.
        Return: the list of node and the list of edge(node index -> [node index])
        Notice that for every graph, the node 0 and the node self.node_num + 1
        is the input node and the output node.'''
        self._random_graph_generator()
        return self.parse_graph(self.graph) #static method parse_graph can't call self. But the instance method generate_graph can call self

    def get_graph_info(self):
        return self.parse_graph(self.graph)

    def save_graph(self, path):   # save the nx.graph instead of parsed graph
        nx.write_gpickle(self.graph, path)
    
    def load_graph(self, path):   # load the nx.graph and parse it
        self.graph = nx.read_gpickle(path)
        self.node_num = self.graph.number_of_nodes()
        return self.parse_graph(self.graph)

'''Assemble a subgraph'''
class TestSubgraph(nn.Module):
    def __init__(self, 
                 input_cell, 
                 cell_graph,  #only a kind of normal cell. Replicate it len(nodes-2) times and map them to nodes-2
                 output_cell,
                 in_shape,
                 out_shape,
                 nodes,
                 edges):
        super(TestSubgraph, self).__init__()
        self.input_cell = input_cell
        self.normal_cell_graph = cell_graph #subnode_list, cell_topology, split_tree, shape_info
        normal_cell_list = list()
        for i in range(1, len(nodes)-1):
            degree = len(edges[i])
            normal_cell_list.append(opp.Cell(degree, cell_graph[0], cell_graph[1], cell_graph[2]))
        self.normal_cell_list = nn.ModuleList(normal_cell_list)
        self.output_cell = output_cell
        self.in_shape = in_shape
        self.output_shape = out_shape
        self.nodes = nodes
        self.edges = edges
    
    def forward(self, x):
        out = self.input_cell(x)
        memory = OrderedDict()
        memory[0] = out
        for idx in range(1, len(self.nodes)-1):
            out = self.normal_cell_list[idx-1](*[memory[in_vertex] for in_vertex in self.edges[idx]])
            memory[idx] = out
        last_cell = self.nodes[-1]
        output_cell_input = [memory[in_vertex] for in_vertex in self.edges[last_cell]]
        out = self.output_cell(*output_cell_input)
        return out
    
#Class recorder can append subgraph, record opt seq, clear subgraph, save and load     
class recorder:
    def __init__(self, save_prefix_path=None, load_prefix_path=None):
        self.random_graphs = list()
        self.sub_graph_params = list()
        self.save_prefix_path = save_prefix_path
        self.load_prefix_path = load_prefix_path
        self.opt_seq = 3 # default optimization level, could 
    
    #append subgraph and set its params
    def push(self, 
             sub_graph: RandomGraph, 
             input_cell,
             cell_graph: tuple,
             output_cell,
             input_shape: list,
             output_shape: list,
             nodes: list,
             edges: list):
        self.random_graphs.append(sub_graph)
        self.sub_graph_params.append([
            input_cell, cell_graph, output_cell,
            input_shape, output_shape,
            nodes, edges])
    
    def record_opt_seq(self, seq):
        self.opt_seq = seq
        
    def clear(self):
        self.random_graphs.clear()
        self.sub_graph_params.clear()
        
    def save(self, infix=None):
        prefix = self.save_prefix_path
        if infix == None:
            infix = ""
        number = 0
        dir_path = os.path.join(prefix, infix+"_{}".format(number), "")
        while(os.path.exists(dir_path)):
            # find a dir name that doesn't exist
            number += 1
            dir_path = os.path.join(prefix, infix+"_{}".format(number), "")
        os.makedirs(dir_path)
        for idx in range(len(self.random_graphs)):
            # save every subgraph to a dir
            sub_dir = os.path.join(dir_path, str(idx), "")
            os.makedirs(sub_dir)
            random_graph = self.random_graphs[idx]
            random_graph.save_graph(sub_dir+"graph_topology.gpickle")
            sub_graph = self.sub_graph_params[idx]
            torch.save(sub_graph[0], sub_dir+"input_cell.pt")
            torch.save(sub_graph[1], sub_dir+"cell_graph.pt")
            torch.save(sub_graph[2], sub_dir+"output_cell.pt")
            torch.save([sub_graph[3], sub_graph[4]], sub_dir+"shape.pt")
            torch.save([sub_graph[5], sub_graph[6]], sub_dir+"nodes_edges.pt")
        return dir_path
    
    def load(self, dir_name):
        self.sub_graph_params.clear()
        self.random_graphs.clear()
        prefix = self.load_prefix_path
        dir_path = os.path.join(prefix, dir_name, "")
        sub_dirs = [name for name in os.listdir(dir_path) if os.path.isdir(os.path.join(dir_path, name))]
        sub_dirs = sorted(sub_dirs, key=lambda x: int(x))
        for sub in sub_dirs:
            sub_dir = os.path.join(dir_path, sub, "")
            graph_topology = RandomGraph(-1, None)
            graph_topology.load_graph(sub_dir+"graph_topology.gpickle")
            self.random_graphs.append(graph_topology)
            input_cell = torch.load(sub_dir+"input_cell.pt")
            cell_graph = torch.load(sub_dir+"cell_graph.pt")
            output_cell = torch.load(sub_dir+"output_cell.pt")
            input_shape, output_shape = torch.load(sub_dir+"shape.pt")
            nodes, edges = torch.load(sub_dir+"nodes_edges.pt")
            self.sub_graph_params.append([
                input_cell, cell_graph, output_cell,
                input_shape, output_shape,
                nodes, edges])
            
            


        
def get_sub_graph(input_shape, output_shape, node_num, graph_mode, sampling_method=None, recorder=None, **graph_param):
    """
    Generate subgraph according to the order:
    Input_cell: a conv2d, its input shape is input_shape, its output shape is output_shape
        |
    cell_graph: cell, input.shape=output.shape=output_shape
        |
    Ouput_cell: 

    Input_cell: change shape from input_shape to output_shape.
    cell_graph: sub graph generated from random graph generator.
    Output_cell: WeightSum that combine multiple output into one single output.
    """
    #graph_param in function is a dict
    

    if sampling_method is None:
        # Get topology of random sub graph 
        sub_graph = RandomGraph(node_num, graph_mode, **graph_param)
        nodes, edges = sub_graph.generate_graph()
        #print('----------------------------------------------')
        #print(f'nodes are {nodes}')
        #print(f'edges are {edges}')
        # Sample input cell
        # down sampling
        subnode = opc.Conv2d()
        constraint = subnode.input_conversion(input_shape, output_shape) #dict contains variables to constrained
        params = subnode.get_possible_params(constraint)  
        #print('-------------------------------------------')
        #print(f'get_possible_params is {params}') #param is dict, each element contains a set of params
        # random sampler for now
        # TODO: add more sampling methods
        sample_idx = random.randint(0, len(params)-1)  #random params of Conv2d
        input_cell = subnode.get_node(params[sample_idx])  #input_cell is an instance of nn.Conv2d
        # Sample normal cell
        if sampling_method is None:
            cell_graph = opp.get_cell(output_shape) #in op_projection.py
            #print(f'cell_graph is {cell_graph}')
        # Sample output cell
        
        #nodes[-1] is the end node's index. edges' last element represents the input nodes of the end node
        #instantiate an output_cell of a subgraph
        output_cell = opc.WeightSum(len(edges[nodes[-1]]))  
        test_subgraph = TestSubgraph(input_cell, cell_graph, 
                                    output_cell, input_shape, output_shape, 
                                    nodes, edges)  
        #TestSubgraph assemble all cells into a subgraph
        #a subgraph consists of a conv2d input_cell, replicate a normal cell and project them into the random graph topology, then connecting to an WeightSum output cell
        
        if recorder != None:
            recorder.push(
                sub_graph, input_cell, cell_graph,
                output_cell, input_shape, output_shape,
                nodes, edges
            )
    else:
        raise NotImplementedError
    return test_subgraph